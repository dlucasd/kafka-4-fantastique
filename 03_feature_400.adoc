== 4.0.0

=== M√©triques clients via broker

image::images/metrics.svg[opts=inline, width=100%, height=500]


[.notes]
--
* probl√®me : pas d'interface standard, manque de visibilit√© sur les m√©triques applicatives
* *registerMetricForSubscription*(KafkaMetric metric) / *unregisterMetricFromSubscription*(KafkaMetric metric)
* R√©sultat: *observabilit√© ‚Äúcompl√®te‚Äù*
* Types de m√©triques limit√©s (sum/gauge) Sum : Compteur monotone (par exemple, nombre total de messages trait√©s). Gauge : Valeur non monotone (par exemple, taux de traitement).
--

[%notitle]
=== Impl√©mentation m√©trique

[.large-code-exemple]
--

[source,java,highlight=1..2|4..5|6..11|16..17]
----
Metrics local = new Metrics(new MetricConfig());
Sensor messageSensor = local.sensor("message-count-sensor");

LinkedHashMap<String, String> tags = new LinkedHashMap<>();
tags.put("component", "my-app");
MetricName metricName = new MetricName(
    "total-messages-processed",
    "application",
    "Total messages processed",
    tags
);

messageSensor.add(metricName, new CumulativeCount());
KafkaMetric metric = local.metrics().get(metricName);

consumer.registerMetricForSubscription(metric);
consumer.unregisterMetricFromSubscription(metric);
----

--

=== auto.offset.reset


image:images/resetOffsetDuration.svg[opts=inline, width=100%]

[.notes]
--
* Offset reset depuis une dur√©e
* Tirer parti du stockage longue dur√©e (tiered storage)pour reprendre ‚Äú√† X temps en arri√®re‚Äù
* usages : data analytics, reprise sur incident
* KIP-1106
--

=== Format ISO-8601

* PnDTnHnMn.nS
* Exemples:
** P30D ‚Üí 30 jours
** PT12H ‚Üí 12 heures
** P1DT30M ‚Üí 1 jour et 30 minutes

=== Topology

image::images/topology.svg[opts=inline, width=70%]


[.notes]
--
* probl√®me: il faut cr√©er un processor custom et l'injecter manuellement dans toutes les topologies
* donne un ‚Äúhook‚Äù officiel et propre pour injecter une couche transversale (log/metrics/tracing/tests) sur tous tes processors Streams (DSL/Processor API) via un ProcessorWrapper configurable au build de la topologie
* KIP-1112
--

=== Impl√©mentation exemple

[.large-code-exemple]
--

[source,java,highlight=1..2|6..7|11..14|28..31|16..26|37..39]
----
public class LoggingProcessorWrapper<KIn, VIn, KOut, VOut> 
  implements ProcessorWrapper<KIn, VIn, KOut, VOut> {

...

    private static class LoggingProcessor<KIn, VIn, KOut, VOut> 
       implements Processor<KIn, VIn, KOut, VOut>, ProcessorContextAware {

        ...

        @Override
        public void init(ProcessorContext<KOut, VOut> context) {
            delegate.init(context);
        }

        @Override
        public void process(Record<KIn, VIn> record) {
            Instant start = Instant.now();
            logger.info("Entr√©e dans le processeur");

            delegate.process(record);

            var duration = Duration.between(start, Instant.now());
            logger.info("Sortie du processeur : dur√©e={}", duration.toMillis());
        }

        @Override
        public void close() {
            delegate.close();
        }
    }
}



________________________________
application.properties:

processor.wrapper.class=com.mirakl.LoggingProcessorWrapper


----

--

[.notes]
--
* introduit une interface ProcessorWrapper
* wrapper au m√™me titre que pattern delegate ou decorator
* cas d'usage :
** audit, logging, m√©triques, tracing
** gestion d'erreurs/retry (ex: dead-letter queue)
** possibilit√© de faire du feature flag
* test : permet de simuler des erreurs pour valider le comportement de l'application, chaos wrapper
* KIP-1112 - 4.0.0
--


=== Rebalance


[%notitle]
=== Avant

image:images/classicRebalance.svg[opts=inline, width=80%]

[.notes]
--
* probl√®me : 
** "stop the world" = "synchronisation barrier"
** difficile de trouver la *root cause* car beaucoup d'√©changes
** s'il y a un *consumer qui a du lag* ? tout le groupe attend
--

[%notitle]
=== Apr√®s

image:images/consumerRebalance.svg[opts=inline, width=80%]

[%notitle.blue.background]
=== Perf consommation 

image:images/throughputRebalance.png[]

[.notes]
--
* provenance de l'√©tude : https://current.confluent.io/2024-sessions/the-performance-of-kafkas-new-consumer-rebalance-protocol
* production constante √† 29 MB/s
* 1 consommateur *avec lag important* impacte tout le groupe
--
=== Consumer Group Protocol

[.step.without-bullets]
* üîÅ Rebalance incr√©mental
* üéØ G√©r√© par le coordinator, facilite le d√©bug
* ‚öôÔ∏è Activ√© par d√©faut c√¥t√© serveur, c√¥t√© client : `group.protocol=consumer`
* ‚öñÔ∏è Compromis : usage CPU c√¥t√© serveur, empreinte m√©moire plus √©lev√©e
* üíª Outils d'admin : kafka-groups.sh, kafka-consumer-groups.sh


[.notes]
--
* ce n'est pas activ√© par d√©faut car il faut que le consumer et broker soient tous les 2 en 4.0
* profite √©galement √† Kafka Connect car protocol con√ßu de mani√®re g√©n√©rique : il assigne des ressources √† des groupes
* KIP-848 - 4.0.0
--

=== Streams rebalance protocol

[.step.without-bullets]
* üß™ Early access en 4.1.0
* üß© Se base sur le Consumer Group Protocol
* üîÄ M√™me principe mais pour l'assignation des t√¢ches Kafka Streams

[.notes]
--
* KIP-1071
--

=== Queues

[.step]
en early access

[.notes]
--
* On se garde √ßa pour plus tard car c'est en preview dans la 4.1.0
* KIP-1099
--
